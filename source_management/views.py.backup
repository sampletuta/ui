import requests
import json
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse, StreamingHttpResponse, FileResponse
from django.core.paginator import Paginator
from django.conf import settings
from django.utils import timezone
from django.db import transaction
import os
import json
import logging
import uuid
import threading
import re
import subprocess
from .models import CameraSource, FileSource, StreamSource

logger = logging.getLogger(__name__)
from .forms import CameraSourceForm, FileSourceForm, StreamSourceForm


def _range_streaming_response(request, file_path, content_type='video/mp4', chunk_size=8192):
    """Efficient HTTP range streaming helper for large files."""
    file_size = os.path.getsize(file_path)
    range_header = request.META.get('HTTP_RANGE', '').strip()
    range_match = re.match(r'bytes=(\d+)-(\d*)', range_header)
    if range_match:
        start = int(range_match.group(1))
        end = int(range_match.group(2)) if range_match.group(2) else file_size - 1
        if start >= file_size:
            return HttpResponse(status=416)

        def file_iterator(path, start_pos, end_pos, block_size=chunk_size):
            with open(path, 'rb') as f:  # File is closed automatically when generator finishes
                f.seek(start_pos)
                remaining = end_pos - start_pos + 1
                while remaining > 0:
                    data = f.read(min(block_size, remaining))
                    if not data:
                        break
                    remaining -= len(data)
                    yield data

        response = StreamingHttpResponse(file_iterator(file_path, start, end), content_type=content_type)
        response['Content-Range'] = f'bytes {start}-{end}/{file_size}'
        response['Accept-Ranges'] = 'bytes'
        response['Content-Length'] = str(end - start + 1)
        response.status_code = 206
        return response

    # Full-file streaming using FileResponse for optimal performance
    response = FileResponse(open(file_path, 'rb'), content_type=content_type)
    response['Accept-Ranges'] = 'bytes'
    response['Content-Length'] = str(file_size)
    return response

def login_required_source_list(view_func):
    def _wrapped_view(request, *args, **kwargs):
        if request.user.is_authenticated:
            return view_func(request, *args, **kwargs)
        else:
            return redirect('login')
    return _wrapped_view

@login_required_source_list
def source_list(request):
    """List all sources"""
    sources = []
    
    # Performance: limit fields and rows fetched; compute counts separately
    limit_total = getattr(settings, 'SOURCE_LIST_MAX_ITEMS', 500)
    per_type_limit = max(1, limit_total // 3)

    file_sources_qs = (
        FileSource.objects.only('source_id', 'name', 'location', 'status', 'created_at', 'file_size', 'access_token')
        .order_by('-created_at')[:per_type_limit]
    )
    camera_sources_qs = (
        CameraSource.objects.only('source_id', 'name', 'location', 'created_at', 'zone', 'is_active', 'camera_ip', 'camera_port')
        .order_by('-created_at')[:per_type_limit]
    )
    stream_sources_qs = (
        StreamSource.objects.only('source_id', 'name', 'location', 'created_at', 'stream_protocol')
        .order_by('-created_at')[:per_type_limit]
    )
    
    # Combine and format sources
    for source in file_sources_qs:
        sources.append({
            'source_id': source.source_id,
            'name': source.name,
            'type': 'file',
            'type_display': 'Video File',
            'location': source.location,
            'status': source.status,
            'created_at': source.created_at,
            'file_size': source.file_size,
            'access_token': source.access_token[:8] + '...' if source.access_token else None,
            'zone': getattr(source, 'zone', ''),
            'is_active': getattr(source, 'is_active', True),
            'color': 'success',
            'icon': 'fa-file-video',
            'info': f'Size: {source.get_file_size_display()}' if source.file_size else 'File uploaded',
        })
    
    for source in camera_sources_qs:
        sources.append({
            'source_id': source.source_id,
            'name': source.name,
            'type': 'camera',
            'type_display': 'IP Camera',
            'location': source.location,
            'status': 'active' if source.is_active else 'inactive',
            'created_at': source.created_at,
            'zone': source.zone,
            'is_active': source.is_active,
            'color': 'primary',
            'icon': 'fa-video-camera',
            'info': f'{source.camera_ip}:{source.camera_port}' if source.camera_ip else 'Camera configured',
        })
    
    for source in stream_sources_qs:
        sources.append({
            'source_id': source.source_id,
            'name': source.name,
            'type': 'stream',
            'type_display': 'Video Stream',
            'location': source.location,
            'status': 'active',
            'created_at': source.created_at,
            'zone': getattr(source, 'zone', ''),
            'is_active': getattr(source, 'is_active', True),
            'color': 'info',
            'icon': 'fa-broadcast-tower',
            'info': f'{source.stream_protocol.upper()} stream' if hasattr(source, 'stream_protocol') else 'Stream configured',
        })
    
    # Sort by creation date (newest first)
    sources.sort(key=lambda x: x['created_at'], reverse=True)
    
    # Pagination
    paginator = Paginator(sources, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Compute counts without loading full rows
    file_sources_count = FileSource.objects.count()
    camera_sources_count = CameraSource.objects.count()
    stream_sources_count = StreamSource.objects.count()

    context = {
        'sources': page_obj,
        'total_sources': file_sources_count + camera_sources_count + stream_sources_count,
        'file_sources_count': file_sources_count,
        'camera_sources_count': camera_sources_count,
        'stream_sources_count': stream_sources_count,
    }
    return render(request, 'source_management/source_list.html', context)

#@login_required
@login_required_source_list
def source_create(request):
    """Create a new source"""
    if request.method == 'POST':
        source_type = request.POST.get('source_type', 'file')
        
        if source_type == 'file':
            form = FileSourceForm(request.POST, request.FILES)
        elif source_type == 'camera':
            form = CameraSourceForm(request.POST)
        elif source_type == 'stream':
            form = StreamSourceForm(request.POST)
        else:
            messages.error(request, 'Invalid source type')
            return redirect('source_management:source_list')
        
        if form.is_valid():
            try:
                with transaction.atomic():
                    # Create the source object
                    source = form.save(commit=False)
                    source.source_id = uuid.uuid4()
                    source.created_by = request.user
                    
                    # For file sources, handle file upload and metadata extraction
                    if source_type == 'file':
                        file_source = source
                        # If uploaded via chunked path, assemble final file path from existing file
                        chunked_upload_id = request.POST.get('chunked_upload_id') or form.cleaned_data.get('chunked_upload_id')
                        chunked_original_filename = request.POST.get('chunked_original_filename') or form.cleaned_data.get('chunked_original_filename')
                        if chunked_upload_id and chunked_original_filename and not request.FILES.get('video_file'):
                            # Move/rename the pre-assembled chunked upload into videos storage
                            from django.core.files import File
                            final_dir = os.path.join(settings.MEDIA_ROOT, 'search_videos')
                            assembled_path = os.path.join(final_dir, f'{chunked_upload_id}_{chunked_original_filename}')
                            if not os.path.exists(assembled_path):
                                raise Exception('Assembled upload not found. Please retry upload.')
                            # Ensure videos directory exists
                            videos_dir = os.path.join(settings.MEDIA_ROOT, 'videos')
                            os.makedirs(videos_dir, exist_ok=True)
                            target_path = os.path.join(videos_dir, chunked_original_filename)
                            # Move the file
                            os.replace(assembled_path, target_path)
                            # Attach to model FileField
                            with open(target_path, 'rb') as f:
                                file_source.video_file.save(os.path.basename(target_path), File(f), save=False)
                                # Remove the temp file after saving into storage backend
                            try:
                                os.remove(target_path)
                            except OSError:
                                pass

                        # Generate access token and API endpoint
                        file_source.access_token = uuid.uuid4().hex
                        file_source.api_endpoint = f"{request.scheme}://{request.get_host()}/source-management/api/video/{file_source.access_token}/"
                        file_source.stream_url = f"{request.scheme}://{request.get_host()}/source-management/api/video/{file_source.access_token}/stream/"
                        file_source.thumbnail_url = f"{request.scheme}://{request.get_host()}/source-management/api/video/{file_source.access_token}/thumbnail/"
                        
                        # Set initial status and extract basic metadata
                        file_source.status = 'uploading'
                        file_source.processing_started_at = timezone.now()
                        
                        # Extract basic file metadata
                        if file_source.video_file:
                            file_source.file_format = os.path.splitext(file_source.video_file.name)[1][1:].lower()
                            file_source.file_size = file_source.video_file.size
                        
                        # Save the file source
                        file_source.save()
                        
                        # Notify data ingestion service about new source
                        def _notify_data_ingestion():
                            try:
                                from .services import DataIngestionService
                                ingestion_service = DataIngestionService()
                                result = ingestion_service.notify_new_source(file_source)
                                
                                # Update file source with notification status
                                if result['success']:
                                    file_source.ingestion_notified = True
                                    file_source.ingestion_notified_at = timezone.now()
                                    file_source.ingestion_response = result.get('response', {})
                                    file_source.status = 'ready'
                                    file_source.processing_completed_at = timezone.now()
                                else:
                                    # Log error but don't fail the source creation
                                    logger.warning(f"Failed to notify data ingestion service: {result.get('error', 'Unknown error')}")
                                    file_source.status = 'ready'  # Still mark as ready
                                    file_source.processing_completed_at = timezone.now()
                                
                                file_source.save()
                                
                            except Exception as e:
                                logger.error(f"Error notifying data ingestion service: {e}")
                                # Don't fail the source creation, just mark as ready
                                file_source.status = 'ready'
                                file_source.processing_completed_at = timezone.now()
                                file_source.save()

                        # Run notification in background thread
                        transaction.on_commit(_notify_data_ingestion)
                        
                        messages.success(request, f'File source "{file_source.name}" created successfully. Notifying data ingestion service...')
                        return redirect('source_management:file_detail', source_id=file_source.source_id)
                    
                    else:
                        # For camera and stream sources
                        source.save()
                        messages.success(request, f'{source_type.title()} source "{source.name}" created successfully.')
                        return redirect('source_management:' + source_type + '_detail', source_id=source.source_id)
                        
            except Exception as e:
                # If anything fails, the transaction will be rolled back
                messages.error(request, f'Error creating {source_type} source: {str(e)}')
                return redirect('source_management:source_list')
        else:
            messages.error(request, 'Please correct the errors below.')
    else:
        # GET request - show form
        source_type = request.GET.get('type', 'file')
        if source_type == 'file':
            form = FileSourceForm()
        elif source_type == 'camera':
            form = CameraSourceForm()
        elif source_type == 'stream':
            form = StreamSourceForm()
        else:
            form = FileSourceForm()
    
    context = {
        'form': form,
        'source_type': source_type,
    }
    # Provide chunking config to template for file uploads
    try:
        if source_type == 'file':
            context['chunk_threshold'] = getattr(settings, 'CHUNKED_UPLOAD_THRESHOLD', 100 * 1024 * 1024)
            context['chunk_size'] = getattr(settings, 'CHUNK_SIZE', 1024 * 1024)
    except Exception:
        pass
    return render(request, 'source_management/source_form.html', context)

#@login_required
@login_required_source_list
def source_detail(request, source_id):
    """View source details"""
    # Try to find the source in any of the models
    source = None
    source_type = None
    
    try:
        source = FileSource.objects.get(source_id=source_id)
        source_type = 'file'
    except FileSource.DoesNotExist:
        pass
    
    if not source:
        try:
            source = CameraSource.objects.get(source_id=source_id)
            source_type = 'camera'
        except CameraSource.DoesNotExist:
            pass
    
    if not source:
        try:
            source = StreamSource.objects.get(source_id=source_id)
            source_type = 'stream'
        except StreamSource.DoesNotExist:
            pass
    
    if not source:
        messages.error(request, 'Source not found.')
        return redirect('source_management:source_list')
    
    context = {
        'source': source,
        'source_type': source_type,
    }
    
    return render(request, 'source_management/source_detail.html', context)

#@login_required
@login_required_source_list
def source_update(request, source_id):
    """Update source details"""
    # Try to find the source in any of the models
    source = None
    source_type = None
    form_class = None
    
    try:
        source = FileSource.objects.get(source_id=source_id)
        source_type = 'file'
        form_class = FileSourceForm
    except FileSource.DoesNotExist:
        pass
    
    if not source:
        try:
            source = CameraSource.objects.get(source_id=source_id)
            source_type = 'camera'
            form_class = CameraSourceForm
        except CameraSource.DoesNotExist:
            pass
    
    if not source:
        try:
            source = StreamSource.objects.get(source_id=source_id)
            source_type = 'stream'
            form_class = StreamSourceForm
        except StreamSource.DoesNotExist:
            pass
    
    if not source:
        messages.error(request, 'Source not found.')
        return redirect('source_management:source_list')
    
    if request.method == 'POST':
        form = form_class(request.POST, request.FILES, instance=source)
        if form.is_valid():
            form.save()
            messages.success(request, f'{source_type.title()} source "{source.name}" updated successfully.')
            return redirect('source_management:' + source_type + '_detail', source_id=source.source_id)
        else:
            messages.error(request, 'Please correct the errors below.')
    else:
        form = form_class(instance=source)
    
    context = {
        'form': form,
        'source': source,
        'source_type': source_type,
    }
    return render(request, 'source_management/source_form.html', context)

#@login_required
@login_required_source_list
def source_delete(request, source_id):
    """Delete a source"""
    # Try to find the source in any of the models
    source = None
    source_type = None
    
    try:
        source = FileSource.objects.get(source_id=source_id)
        source_type = 'file'
    except FileSource.DoesNotExist:
        pass
    
    if not source:
        try:
            source = CameraSource.objects.get(source_id=source_id)
            source_type = 'camera'
        except CameraSource.DoesNotExist:
            pass
    
    if not source:
        try:
            source = StreamSource.objects.get(source_id=source_id)
            source_type = 'stream'
        except StreamSource.DoesNotExist:
            pass
    
    if not source:
        messages.error(request, 'Source not found.')
        return redirect('source_management:source_list')
    
    if request.method == 'POST':
        try:
            with transaction.atomic():
                # Delete the source
                source_name = source.name
                source.delete()
                messages.success(request, f'{source_type.title()} source "{source_name}" deleted successfully.')
        except Exception as e:
            messages.error(request, f'Error deleting {source_type} source: {str(e)}')
        
        return redirect('source_management:source_list')
    
    context = {
        'source': source,
        'source_type': source_type,
    }
    return render(request, 'source_management/source_confirm_delete.html', context)

#@login_required
@login_required_source_list
def api_source_metadata(request, source_id):
    """API endpoint to get source metadata"""
    try:
        # Try to find the source in any of the models
        source = None
        source_type = None
        
        try:
            source = FileSource.objects.get(source_id=source_id)
            source_type = 'file'
        except FileSource.DoesNotExist:
            pass
        
        if not source:
            try:
                source = CameraSource.objects.get(source_id=source_id)
                source_type = 'camera'
            except CameraSource.DoesNotExist:
                pass
        
        if not source:
            try:
                source = StreamSource.objects.get(source_id=source_id)
                source_type = 'stream'
            except StreamSource.DoesNotExist:
                pass
        
        if not source:
            return JsonResponse({'error': 'Source not found'}, status=404)
        
        # Return metadata
        metadata = {
            'id': str(source.source_id),
            'name': source.name,
            'type': source_type,
            'description': source.description,
            'location': source.location,
            'created_at': source.created_at.isoformat(),
            'updated_at': source.updated_at.isoformat(),
        }
        
        # Add type-specific metadata
        if source_type == 'file':
            metadata.update({
                'status': source.status,
                'file_size': source.file_size,
                'duration': source.duration,
                'resolution': f"{source.width}x{source.height}" if source.width and source.height else None,
                'fps': source.fps,
                'codec': source.codec,
                'access_token': source.access_token,
                'api_endpoint': source.api_endpoint,
                'stream_url': source.stream_url,
                'thumbnail_url': source.thumbnail_url,
            })
        elif source_type == 'camera':
            metadata.update({
                'camera_ip': source.camera_ip,
                'camera_port': source.camera_port,
                'camera_protocol': source.camera_protocol,
                'is_active': source.is_active,
            })
        elif source_type == 'stream':
            metadata.update({
                'stream_url': source.stream_url,
                'stream_protocol': source.stream_protocol,
                'stream_quality': source.stream_quality,
            })
        
        return JsonResponse(metadata)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

# New API endpoints for video access
@login_required_source_list
def api_video_access(request, access_token):
    """API endpoint for video access using access token"""
    try:
        # Find file source by access token
        file_source = FileSource.objects.get(access_token=access_token)
        
        if file_source.status != 'ready':
            return JsonResponse({
                'error': 'Video not ready',
                'status': file_source.status
            }, status=400)
        
        # Return video information
        response_data = {
            'id': str(file_source.source_id),
            'name': file_source.name,
            'description': file_source.description,
            'status': file_source.status,
            'file_size': file_source.file_size,
            'duration': file_source.duration,
            'resolution': f"{file_source.width}x{file_source.height}" if file_source.width and file_source.height else None,
            'fps': file_source.fps,
            'codec': file_source.codec,
            'audio_codec': file_source.audio_codec,
            'bitrate': file_source.bitrate,
            'created_at': file_source.created_at.isoformat(),
            'download_url': f"/source-management/api/video/{access_token}/download/",
            'stream_url': f"/source-management/api/video/{access_token}/stream/",
            'thumbnail_url': f"/source-management/api/video/{access_token}/thumbnail/",
        }
        
        return JsonResponse(response_data)
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required_source_list
def api_video_metadata(request, access_token):
    """API endpoint for video metadata"""
    try:
        file_source = FileSource.objects.get(access_token=access_token)
        
        metadata = {
            'id': str(file_source.source_id),
            'name': file_source.name,
            'file_size': file_source.file_size,
            'duration': file_source.duration,
            'width': file_source.width,
            'height': file_source.height,
            'fps': file_source.fps,
            'codec': file_source.codec,
            'audio_codec': file_source.audio_codec,
            'audio_channels': file_source.audio_channels,
            'audio_sample_rate': file_source.audio_sample_rate,
            'bitrate': file_source.bitrate,
            'file_format': file_source.file_format,
            'status': file_source.status,
        }
        
        return JsonResponse(metadata)
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required_source_list
def api_video_download(request, access_token):
    """API endpoint for video download"""
    try:
        file_source = FileSource.objects.get(access_token=access_token)
        
        if file_source.status != 'ready':
            return JsonResponse({'error': 'Video not ready'}, status=400)
        
        video_file = file_source.video_file
        if not video_file:
            return JsonResponse({'error': 'Video file not found'}, status=404)
        
        # Stream the file efficiently
        response = FileResponse(video_file.open('rb'), as_attachment=True, filename=os.path.basename(video_file.name), content_type='video/mp4')
        return response
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required_source_list
def api_video_stream(request, access_token):
    """API endpoint for video streaming"""
    try:
        file_source = FileSource.objects.get(access_token=access_token)
        
        if file_source.status != 'ready':
            return JsonResponse({'error': 'Video not ready'}, status=400)
        
        video_file = file_source.video_file
        if not video_file:
            return JsonResponse({'error': 'Video file not found'}, status=404)
        
        # Get file path
        file_path = video_file.path
        
        # Check if file exists
        if not os.path.exists(file_path):
            return JsonResponse({'error': 'Video file not found on disk'}, status=404)
        
        return _range_streaming_response(request, file_path, content_type='video/mp4')
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

# Video Processing Views
@login_required_source_list
def submit_video_processing(request, source_id):
    """Submit a video for processing to external service"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the file source
        file_source = FileSource.objects.get(source_id=source_id)
        
        if file_source.status != 'ready':
            return JsonResponse({
                'error': 'Video not ready for processing',
                'status': file_source.status
            }, status=400)
        
        # Get processing parameters from request
        target_fps = request.POST.get('target_fps')
        target_resolution = request.POST.get('target_resolution')
        
        if not target_fps or not target_resolution:
            return JsonResponse({
                'error': 'Missing required parameters: target_fps and target_resolution'
            }, status=400)
        
        try:
            target_fps = int(target_fps)
            # Align with FastPublisher limit (1-5)
            if not (1 <= target_fps <= 5):
                return JsonResponse({
                    'error': 'target_fps must be between 1 and 5'
                }, status=400)
        except ValueError:
            return JsonResponse({
                'error': 'target_fps must be a valid integer'
            }, status=400)
        
        # Validate resolution format (e.g., "640x480")
        if not re.match(r'^\d+x\d+$', target_resolution):
            return JsonResponse({
                'error': 'target_resolution must be in format "widthxheight" (e.g., "640x480")'
            }, status=400)
        
        # Import and use the processing service
        from .services import VideoProcessingService
        processing_service = VideoProcessingService()
        
        # Submit the job
        result = processing_service.submit_video_processing(
            file_source, target_fps, target_resolution
        )
        
        if result['success']:
            return JsonResponse({
                'status': 'success',
                'message': 'Video processing job submitted successfully',
                'job_id': result['job_id'],
                'external_job_id': result.get('external_job_id'),
                'estimated_completion_time': 'Calculating...',
                'processing_started_at': timezone.now().isoformat()
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': result['error'],
                'details': result.get('details', '')
            }, status=500)
            
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Unexpected error: {str(e)}'
        }, status=500)

@login_required_source_list
def get_processing_status(request, job_id):
    """Get the status of a processing job"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        from .services import VideoProcessingService
        processing_service = VideoProcessingService()
        
        result = processing_service.get_job_status(job_id)
        
        if result['success']:
            return JsonResponse({
                'status': 'success',
                'job_id': result['job_id'],
                'external_job_id': result['external_job_id'],
                'current_status': result['status'],
                'external_status': result['external_status'],
                'response': result['response']
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': result['error']
            }, status=404)
            
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Unexpected error: {str(e)}'
        }, status=500)

@login_required_source_list
def cancel_processing_job(request, job_id):
    """Cancel a processing job"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        from .services import VideoProcessingService
        processing_service = VideoProcessingService()
        
        result = processing_service.cancel_job(job_id)
        
        if result['success']:
            return JsonResponse({
                'status': 'success',
                'message': result['message']
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': result['error']
            }, status=400)
            
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Unexpected error: {str(e)}'
        }, status=500)

def processing_callback(request, access_token):
    """Callback endpoint for external processing service"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Find the processing job by access token
        from .models import VideoProcessingJob
        processing_job = VideoProcessingJob.objects.get(access_token=access_token)
        
        # Parse the callback data
        callback_data = json.loads(request.body)
        
        # Update job status based on callback
        new_status = callback_data.get('status', 'unknown')
        if new_status in ['completed', 'failed']:
            processing_job.update_status(
                new_status,
                external_response=callback_data,
                processed_video_url=callback_data.get('processed_video_url', ''),
                processing_metadata=callback_data.get('processing_metadata', {})
            )
        
        # Log the callback
        logger.info(f"Received callback for job {processing_job.job_id}: {new_status}")
        
        return JsonResponse({'status': 'success', 'message': 'Callback processed'})
        
    except VideoProcessingJob.DoesNotExist:
        return JsonResponse({'error': 'Invalid access token'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON in callback'}, status=400)
    except Exception as e:
        logger.error(f"Error processing callback: {str(e)}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required_source_list
def list_processing_jobs(request, source_id):
    """List all processing jobs for a specific source"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the file source
        file_source = FileSource.objects.get(source_id=source_id)
        
        # Get all processing jobs for this source
        from .models import VideoProcessingJob
        jobs = VideoProcessingJob.objects.filter(source=file_source).order_by('-submitted_at')
        
        jobs_data = []
        for job in jobs:
            jobs_data.append({
                'job_id': job.job_id,
                'external_job_id': job.external_job_id,
                'status': job.status,
                'target_fps': job.target_fps,
                'target_resolution': job.target_resolution,
                'submitted_at': job.submitted_at.isoformat(),
                'started_at': job.started_at.isoformat() if job.started_at else None,
                'completed_at': job.completed_at.isoformat() if job.completed_at else None,
                'error_message': job.error_message,
                'processed_video_url': job.processed_video_url,
            })
        
        return JsonResponse({
            'status': 'success',
            'source_id': str(source_id),
            'source_name': file_source.name,
            'jobs': jobs_data,
            'total_jobs': len(jobs_data)
        })
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Unexpected error: {str(e)}'
        }, status=500)

def fastpublisher_status_check(request, source_id):
    """Simple status endpoint for FastPublisher to check job status"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the file source
        file_source = FileSource.objects.get(source_id=source_id)
        
        # Get the most recent processing job for this source
        from .models import VideoProcessingJob
        latest_job = VideoProcessingJob.objects.filter(source=file_source).order_by('-submitted_at').first()
        
        if not latest_job:
            return JsonResponse({
                'status': 'not_found',
                'message': 'No processing jobs found for this source'
            }, status=404)
        
        # Return simple status for FastPublisher
        return JsonResponse({
            'source_id': str(source_id),
            'job_id': latest_job.job_id,
            'status': latest_job.status,
            'message': latest_job.error_message if latest_job.error_message else 'Job is processing normally',
            'processed_video_url': latest_job.processed_video_url if latest_job.processed_video_url else None
        })
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({
            'error': 'Internal server error',
            'message': str(e)
        }, status=500)

def fastpublisher_video_access(request, source_id):
    """Unauthenticated video access endpoint for FastPublisher"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the file source by source_id (not access_token)
        file_source = FileSource.objects.get(source_id=source_id)
        
        if file_source.status != 'ready':
            return JsonResponse({'error': 'Video not ready'}, status=400)
        
        video_file = file_source.video_file
        if not video_file:
            return JsonResponse({'error': 'Video file not found'}, status=404)
        
        # Get file path
        file_path = video_file.path
        
        # Check if file exists
        if not os.path.exists(file_path):
            return JsonResponse({'error': 'Video file not found on disk'}, status=404)
        
        return _range_streaming_response(request, file_path, content_type='video/mp4')
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

def fastpublisher_submit_video(request, source_id):
    """Unauthenticated video submission endpoint for FastPublisher"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the file source
        file_source = FileSource.objects.get(source_id=source_id)
        
        if file_source.status != 'ready':
            return JsonResponse({
                'error': 'Video not ready for processing',
                'status': file_source.status
            }, status=400)
        
        # Get processing parameters from request
        target_fps = request.POST.get('target_fps')
        target_resolution = request.POST.get('target_resolution')
        
        if not target_fps or not target_resolution:
            return JsonResponse({
                'error': 'Missing required parameters: target_fps and target_resolution'
            }, status=400)
        
        try:
            target_fps = int(target_fps)
            # Align with FastPublisher limit (1-5)
            if not (1 <= target_fps <= 5):
                return JsonResponse({
                    'error': 'target_fps must be between 1 and 5'
                }, status=400)
        except ValueError:
            return JsonResponse({
                'error': 'target_fps must be a valid integer'
            }, status=400)
        
        # Validate resolution format (e.g., "640x480")
        if not re.match(r'^\d+x\d+$', target_resolution):
            return JsonResponse({
                'error': 'target_resolution must be in format "widthxheight" (e.g., "640x480")'
            }, status=400)
        
        # Import and use the processing service
        from .services import VideoProcessingService
        processing_service = VideoProcessingService()
        
        # Submit the job and include health status for debugging
        service_health = processing_service.health()
        result = processing_service.submit_video_processing(
            file_source, target_fps, target_resolution
        )
        
        if result['success']:
            return JsonResponse({
                'status': 'success',
                'message': 'Video processing job submitted successfully',
                'job_id': result['job_id'],
                'external_job_id': result.get('external_job_id'),
                'estimated_completion_time': 'Calculating...',
                'processing_started_at': timezone.now().isoformat(),
                'external_service_url': result.get('external_service_url'),
                'external_service_health': service_health
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': result['error'],
                'details': result.get('details', ''),
                'external_service_url': result.get('external_service_url'),
                'external_service_health': service_health
            }, status=500)
            
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Unexpected error: {str(e)}'
        }, status=500)

def fastpublisher_video_metadata(request, source_id):
    """Unauthenticated video metadata endpoint for FastPublisher"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        file_source = FileSource.objects.get(source_id=source_id)
        
        if file_source.status != 'ready':
            return JsonResponse({'error': 'Video not ready'}, status=400)
        
        metadata = {
            'source_id': str(file_source.source_id),
            'name': file_source.name,
            'file_size': file_source.file_size,
            'duration': file_source.duration,
            'width': file_source.width,
            'height': file_source.height,
            'fps': file_source.fps,
            'codec': file_source.codec,
            'audio_codec': file_source.audio_codec,
            'audio_channels': file_source.audio_channels,
            'audio_sample_rate': file_source.audio_sample_rate,
            'bitrate': file_source.bitrate,
            'file_format': file_source.file_format,
            'status': file_source.status,
            'stream_url': f"/source-management/api/fastpublisher-video/{source_id}/",
            'access_token': file_source.access_token,
        }
        
        return JsonResponse(metadata)
        
    except FileSource.DoesNotExist:
        return JsonResponse({'error': 'Video not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

def fastpublisher_health(request):
    """Proxy health check for FastPublisher so frontend avoids CORS."""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    try:
        from .services import VideoProcessingService
        service = VideoProcessingService()
        health = service.health()
        return JsonResponse({
            'ok': health.get('ok', False),
            'url': health.get('url'),
            'status_code': health.get('status_code'),
            'error': health.get('error'),
            'response': health.get('response')
        }, status=200 if health.get('ok') else 503)
    except Exception as e:
        return JsonResponse({'ok': False, 'error': str(e)}, status=500)

def data_ingestion_health(request):
    """Check data ingestion service health."""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    try:
        from .services import DataIngestionService
        service = DataIngestionService()
        health = service.health()
        return JsonResponse({
            'ok': health.get('ok', False),
            'url': health.get('url'),
            'status_code': health.get('status_code'),
            'error': health.get('error'),
            'response': health.get('response')
        }, status=200 if health.get('ok') else 503)
    except Exception as e:
        return JsonResponse({'ok': False, 'error': str(e)}, status=500)

def data_ingestion_source_status(request, source_id):
    """Get the processing status of a source from the data ingestion service."""
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    try:
        from .services import DataIngestionService
        service = DataIngestionService()
        status_result = service.get_source_status(source_id)
        
        if status_result['success']:
            return JsonResponse(status_result['status'])
        else:
            return JsonResponse({
                'error': status_result['error'],
                'details': status_result.get('details', ''),
                'external_service_url': status_result.get('external_service_url')
            }, status=500)
            
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
