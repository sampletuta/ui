Project: Real-time notifications using django-notifications-hq
Reference: https://github.com/django-notifications/django-notifications

Overview
- Implement GitHub-like notifications for key user and system events (case, targets, searches, video processing).
- Use django-notifications-hq built-in model, tags, and live-updater JS API for near real-time updates (polling).
- Start with minimal integration (badge + dropdown list) and incrementally add event triggers.

Compatibility & Current State
- Django version: requirements.txt pins Django>=4.2,<5.0 (compatible with django-notifications-hq).
- Custom user model: backendapp.CustomUser configured via AUTH_USER_MODEL.
- Navbar has a placeholder notification dropdown in backendapp/templates/base.html.
- notifications app is currently commented out in backend/settings.py.

Phases

Phase 0 — Prerequisites
- Confirm virtualenv is active and pip available.
- Ensure static files pipeline works (whitenoise already enabled).

Phase 1 — Install and enable library
- Add dependency to requirements.txt: django-notifications-hq
- settings.py: add "notifications" to INSTALLED_APPS.
- Optional setting: DJANGO_NOTIFICATIONS_CONFIG = { 'USE_JSONFIELD': True }
- Run: python manage.py migrate

Phase 2 — URL wiring
- backend/urls.py: add
  path('inbox/notifications/', include('notifications.urls', namespace='notifications'))
- Purpose: provides inbox routes and live API endpoints (api/unread_count, api/unread_list).

Phase 3 — Template integration (navbar live-updater)
- backendapp/templates/base.html:
  - At top: {% load notifications_tags %}
  - Include JS: <script src="{% static 'notifications/notify.js' %}"></script>
  - Register callbacks (near other JS includes):
    {% register_notify_callbacks callbacks='fill_notification_list,fill_notification_badge' refresh_period=5 fetch=5 api_name='list' %}
  - Render in navbar:
    - Badge: {% live_notify_badge badge_class="badge" %}
    - List: {% live_notify_list list_class="dropdown-menu" %}
- Result: unread count and a recent unread list update automatically.

Phase 4 — Event triggers (notify.send)
- Goal: Create notifications on meaningful events. Suggested mapping:
  1) SearchResult created (face/object detection)
     - actor: request.user if present, else system (optional)
     - recipient: search_query.user (owner)
     - verb: 'detected'
     - target: target (Targets_watchlist)
     - action_object: search_result
  2) Case created/updated
     - actor: request.user
     - recipient: case.created_by and admins (is_staff=True)
     - verb: 'created case' / 'updated case'
     - target: case
  3) Target added to case; images uploaded
     - actor: request.user
     - recipient: case.created_by
     - verb: 'added target' / 'uploaded images'
     - target: target or case accordingly
  4) Video processing transitions (FileSource ready; VideoProcessingJob status updates)
     - actor: system or request.user
     - recipient: source.created_by
     - verb: 'processing_ready' / 'processing_failed' / 'processing_started'
     - target: file source or job instance

Implementation points
- backendapp/models.py → SearchResult.save:
  - Detect is_new and emit notify.send on first save.
- backendapp/views.py:
  - case_create, case_update, add_target_to_case, add_images: emit notify.send on successful operations.
- source_management/views.py and model methods managing status changes: emit notify.send on state transitions.
- utils (optional): recipient resolution helper to gather admins and owners.

Verb taxonomy
- Use concise, filterable verbs: created, updated, detected, processing_ready, processing_failed, processing_started, uploaded_images, added target.

URLs for model instances
- To improve live list output (target_url, actor_url, action_object_url), add get_absolute_url() to key models:
  - Case, Targets_watchlist, SearchResult, FileSource, VideoProcessingJob as needed.

Phase 5 — Inbox UI (optional)
- Add a menu item linking to '/inbox/notifications/' for a full list page.
- Optionally add custom views to mark all as read, filter by verb or date.

Phase 6 — Custom notification model (optional)
- If custom fields are needed, subclass notifications.base.models.AbstractNotification in an app model and set NOTIFICATIONS_NOTIFICATION_MODEL in settings. Only pursue if requirements arise.

Phase 7 — Permissions & privacy
- Ensure only relevant recipients get notified (owners, involved users, or admins).
- Keep notification descriptions minimal; prefer links to object detail pages over embedding PII.

Phase 8 — Tests
- Unit tests to assert notification creation on each event:
  - Verify actor, recipient, verb, target/action_object, unread status.
- Authenticated requests to api/unread_count and api/unread_list should return expected counts and items.

Phase 9 — Performance & UX
- Start with refresh_period=5s and fetch=5 items.
- Adjust refresh based on load; the API is lightweight but polling should be reasonable.
- Keep payloads small; rely on navigation to detailed pages.

Phase 10 — Rollout checklist
- Run migrations.
- Verify navbar badge increments in real time.
- Verify dropdown shows items and read status updates.
- Validate inbox routes work.
- Smoke test after deploy.

Immediate next steps (to implement now)
1) Add django-notifications-hq to requirements and install.
2) Enable app in INSTALLED_APPS and optional JSONFIELD config.
3) Wire URLs under /inbox/notifications/.
4) Integrate template tags + JS into navbar to show live badge and list.
5) Implement first trigger in SearchResult.save for newly created results.

Acceptance criteria
- Logged-in user sees a notification badge count that updates without page reload.
- Dropdown lists recent unread notifications with appropriate links.
- Creating a SearchResult results in a new unread notification for the query owner.
- No regressions in auth, navbar, or static assets.

Notes
- Email delivery is not included by the library; can be added later if required using Notification.emailed field convention.
- For production, ensure collectstatic and caching are configured as needed.
